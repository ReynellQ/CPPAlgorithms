\documentclass{article}
\usepackage[utf8]{inputenc}
\usepackage{amsmath}
\usepackage{natbib}
\usepackage{graphicx}
\usepackage{listings}
\usepackage{xcolor}

\definecolor{colorGreen}{rgb}{0,0.6,0}
\definecolor{colorGray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{0.95,0.95,0.92}

\lstdefinestyle{mystyle}{
    backgroundcolor=\color{backcolour},   
    commentstyle=\color{colorGreen},
    keywordstyle=\color{blue},
    numberstyle=\tiny\color{colorGray},
    stringstyle=\color{orange},
    basicstyle=\ttfamily\footnotesize,
    breakatwhitespace=false,         
    breaklines=false,                 
    captionpos=b,                    
    keepspaces=true,                 
    numbers=left,                    
    numbersep=5pt,                  
    showspaces=false,   
    showstringspaces=false,
    showtabs=false,                  
    tabsize=2
}

\lstset{style=mystyle}


\title{Handbook}


\begin{document}

\maketitle
\tableofcontents
\pagebreak
\section{Grafos}
    \subsection{Dinic}
        Insertar utilidad del algoritmo:
        \\ \\
        C++:
        \lstinputlisting[language=C++]{C++/Grafos/Dinic.cpp}

    \subsection{Bridges}
        Encuentra las aristas (u, v) que si son retiradas del grafo, producen dos componentes \\
        completamente aisladas.
        \\ \\
        C++:
        \lstinputlisting[language=C++]{C++/Grafos/bridges.cpp}

    \subsection{Articulation Points}
        Encuentra los nodos que si son retirados del grafo, producen dos componentes \\
        completamente aisladas. El algoritmo puede retornar nodos repetidos, las veces que
        estos nodos aparecen son la cantidad de componentes del grafo a la que pertenecen - 1.
        \\ \\
        C++:
        \lstinputlisting[language=C++]{C++/Grafos/articulations.cpp}

\pagebreak
\section{Strings}
    \subsection{Función Z}
        Insertar utilidad del algoritmo:
        \\ \\
        C++:
        \lstinputlisting[language=C++]{C++/Strings/FuncionZ.cpp}
    \subsection{KMP}
        Insertar utilidad del algoritmo:
        \\ \\
        C++:
        \lstinputlisting[language=C++]{C++/Strings/kmp.cpp}
    \subsection{Suffix array}
        Devuelve un arreglo con el orden lexicográfico de los sufijos de un string S
        \\ \\
        C++:
        \lstinputlisting[language=C++]{C++/Strings/Suffix Array/SuffixArray.cpp}
        Java:
        \lstinputlisting[language=Java]{Java/Strings/Suffix Array/SuffixArray.java}
    \subsection{Longest Common Prefix on Suffixs}
        Devuelve un arreglo que contiene el largo del prefijo común máximo entre 2 sufijos i e i+1
        \\ \\
        C++:
        \lstinputlisting[language=C++]{C++/Strings/Suffix Array/LCP.cpp}
        Java:
        \lstinputlisting[language=Java]{Java/Strings/Suffix Array/LCP.java}
    \subsection{Aho Corasick}
        C++:
        \lstinputlisting[language=C++]{C++/Strings/aho_corasick.cpp}
\pagebreak
\section{Búsqueda}
    \subsection{Ternary Search}
        Insertar utilidad del algoritmo:
        \\ \\
        C++:
        \lstinputlisting[language=C++]{C++/ternary_search.cpp}
\pagebreak
\section{Geometría}
    \subsection{Convex Hull}
        Insertar utilidad del algoritmo:
        \\ \\
        C++:
        \lstinputlisting[language=C++]{C++/Geometria/convex_hull.cpp}
    \subsection{Interseccion de lineas}
        C++:
        \lstinputlisting[language=C++]{C++/Geometria/intersection_in_lines.cpp}
    \subsection{Punto en polígono}
        C++:
        \lstinputlisting[language=C++]{C++/Geometria/point_in_polygon.cpp}
    \subsection{Ordenamiento por ángulo polar}
        C++:
        \lstinputlisting[language=C++]{C++/Geometria/sortPointsByAngle.cpp}
    \subsection{Área de polígono}
        C++:
        \lstinputlisting[language=C++]{C++/Geometria/polygon_area.cpp}
      
\pagebreak
\section{Matemáticas}
    \subsection{Factorial modulo m}
        Permite calcular $n! \mod{m}$
        \\ \\
        C++:
        \lstinputlisting[language=C++]{C++/Matematicas/factorial.cpp}
    \subsection{Exponenciacion binaria}
        Permite calcular $c \equiv a^b\pmod{m}$
        \\ \\
        C++:
        \lstinputlisting[language=C++]{C++/Matematicas/bin_pow.cpp}

    \subsection{Inverso Modular}
        Permite calcular $ a^{-1} \mod{m}$, este número satisface $a \cdot a^{-1} \equiv 1 \pmod{m}$
        \\ \\
        Con el pequeño teorema de Fermat, siempre que m sea primo, se calcula $x \equiv a^{m - 2} \pmod{m}$, siendo x su inverso modular.
        \\ \\
        Con el algoritmo de Euclides extendido, siempre y cuando $\gcd(a, m) = 1$, se calculan $x, y$ tal que $ ax + my = 1$, por lo que
        $ax \equiv 1 \pmod{m}$, siendo x el inverso modular 
        \\ \\
        C++:
        \lstinputlisting[language=C++]{C++/Matematicas/inv_mod.cpp}
    \subsection{Inverso modular del factorial modulo m}
        Permite calcular $ i!^{-1} \mod{m}$ para todo $1 \leq i \leq N$
        \\ \\
        C++:
        \lstinputlisting[language=C++]{C++/Matematicas/factorial.cpp}
    \subsection{Coeficientes binomiales modulo m}
        Calculo de $\binom{n}{k} \mod{m}$ de múltiples formas
        \subsubsection{nCk $\mod{m}$ si m es primo}
            Para $m \geq 10^9$, se puede emplear la fórmula recursiva
            \[
                \binom{n}{k} = \binom{n - 1}{k - 1} + \binom{n - 1}{k} \mod{m}
            \]
            O la formula explicita mediante factoriales
            \[
                \binom{n}{k} = \frac{n!}{k!(n-k)!}  \mod m = n!\, k!^{-1}(n - k)!^{-1} \mod{m}
            \]
            \\ \\
            C++:
            \lstinputlisting[language=C++]{C++/Matematicas/combinatorial.cpp}
            
            Para $ m \leq 10^5$, se puede usar el teorema de Lucas que plantea
            \[
                \binom{n}{k} \mod{m} = \prod_{i = 1}^{\log{m}}\binom{n_i}{k_i}
            \]
            Donde
            \[
                n_i = \frac{n_{i - 1}}{m}, \qquad n_0 = n
            \]
            \[
                k_i = \frac{k_{i - 1}}{m}, \qquad k_0 = k
            \]
        \subsubsection{nCk $\mod{m}$ si m es compuesto}
            Se realiza la descomposición en factores primos de m, resultando
            \[
                k_i = \frac{k_{i - 1}}{m}, \qquad k_0 = k
            \]
            Por cada factor primo se computa 
    \subsection{Miller-Rabin}
        Test de primalidad.
        \\ \\
        C++:
        \lstinputlisting[language=C++]{C++/Miller-Rabin.cpp}
    \subsection{Pollard Rho}
        Encontrar un divisor de P.
        \\ \\
        C++:
        \lstinputlisting[language=C++]{C++/Pollard_Rho.cpp}
    \subsection{Inclusión-Exclusión}
        C++:
        \lstinputlisting[language=C++]{C++/Matematicas/inclusion_exclusion.cpp}
    \
\pagebreak
\end{document}